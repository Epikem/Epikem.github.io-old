{"data":{"markdownRemark":{"html":"<h3 id=\"백준-16137---견우와-직녀\"><a href=\"#%EB%B0%B1%EC%A4%80-16137---%EA%B2%AC%EC%9A%B0%EC%99%80-%EC%A7%81%EB%85%80\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>백준 16137 - 견우와 직녀</h3>\n<p><a href=\"https://www.acmicpc.net/problem/16137\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.acmicpc.net/problem/16137</a></p>\n<p>다리를 연속해서 건너서는 안 된다는 조건 때문에 여러 번 틀림. 다 풀었다고 생각되더라도 다시한번 모든 조건을 구현했는지 확인해야겠다. 아니면 처음부터 다양한 조건들을 나타내는 테스트 케이스들을 하나씩 만들어 보는게 좋을수도. </p>\n<p>bfs로는 구현하기 까다롭다고 생각했는데 (주기 다리 건너기 때문에) 검색해보니 bfs로 구현한 사람이 있었다. 다리 사용의 유무 때문에도 bfs로 구현하기 어렵다고 생각했지만 bfs로 구현한 코드가 있다. 그 경우 이전 정보에 대해 필요한 유일한 정보인 이전 위치가 절벽이었는지에 대한 정보를 탐색할 때 얻기 위해, 현재 상태 정보에 현재 위치가 절벽인지에 대한 여부를 상태 정보에 넣는다. 또, 탐색 거리를 건너뛰는 문제에 대한 점은 bfs에서도 visited여부만으로 갱신하는 게 아니라, cost를 더 줄일 수 있으면 탐색함으로써 구현 가능하다.</p>\n<h2 id=\"tags\"><a href=\"#tags\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>tags</h2>\n<p>  #sport, #blog</p>","fields":{"slug":"백준-문제-풀이"},"frontmatter":{"title":"백준 문제 풀이","date":"26.08.2019","category":"sport","tags":["dev/sport","blog"],"banner":"/assets/bg/2.jpg"},"timeToRead":1}},"pageContext":{"slug":"백준-문제-풀이","prev":{"excerpt":"각종 명령어를 치면서 정리하자. 또 금방 까먹는다이전에 했던 것과 비슷한 명령들은 생략.exec /bin/sh in first container of pod named \"monolith\" 및 플래그는 또 뭔가 했더니, 알고보니 가 플래그 줄임이고, 가  플래그의 줄임이었다. 그리고 플래그로 pod 내부의 컨테이너 중 어떤 컨테이너를 대상으로 할 지 선택할 수 있다. 아래는  도움말:Options:\n -c, --container…","html":"<p>각종 명령어를 치면서 정리하자. 또 금방 까먹는다</p>\n<p>이전에 했던 것과 비슷한 명령들은 생략.</p>\n<blockquote>\n<p>exec /bin/sh in first container of pod named \"monolith\"</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ps\"><pre class=\"language-ps\"><code class=\"language-ps\">kubectl exec monolith --stdin --tty /bin/sh\n # is same with:\nkubectl exec monolith -it /bin/sh</code></pre></div>\n<p><code class=\"language-text\">--stdin</code> 및 <code class=\"language-text\">--tty</code>플래그는 또 뭔가 했더니, 알고보니 <code class=\"language-text\">-i</code>가 <code class=\"language-text\">--stdin</code>플래그 줄임이고, <code class=\"language-text\">-t</code>가 <code class=\"language-text\">--tty</code> 플래그의 줄임이었다. 그리고 <code class=\"language-text\">-c</code>플래그로 pod 내부의 컨테이너 중 어떤 컨테이너를 대상으로 할 지 선택할 수 있다. 아래는 <code class=\"language-text\">kubectl exec -h</code> 도움말:</p>\n<blockquote>\n<p>Options:\n-c, --container='': Container name. If omitted, the first container in the pod will be chosen</p>\n<p> -i, --stdin=false: Pass stdin to the container</p>\n<p> -t, --tty=false: Stdin is a TTY</p>\n<p>Usage:\nkubectl exec POD [-c CONTAINER] -- COMMAND [args...][options]</p>\n</blockquote>\n<p>이번 예에서는 https 트래픽을 처리할 수 있는 secure pod를 만들고, 그걸 Service로 외부 노출하여 접속해보는 것으로 보인다.</p>\n<h3 id=\"1\"><a href=\"#1\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.</h3>\n<blockquote>\n<p>create tls certificates from files:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ps\"><pre class=\"language-ps\"><code class=\"language-ps\">ls tls/\n # &gt; ca-key.pem  ca.pem  cert.pem  key.pem\nkubectl create secret generic tls-certs --from-file tls/\n #&gt; secret/tls-certs created</code></pre></div>\n<blockquote>\n<p>generate nginx configmap from file</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ps\"><pre class=\"language-ps\"><code class=\"language-ps\">cat nginx/proxy.conf\n # &gt; server {\n # &gt;   listen 443;\n # &gt;   ssl    on;\n # &gt; \n # &gt;   ssl_certificate     /etc/tls/cert.pem;\n # &gt;   ssl_certificate_key /etc/tls/key.pem;\n # &gt; \n # &gt;   location / {\n # &gt;     proxy_pass http://127.0.0.1:80;\n # &gt;   }\n # &gt; }\n\nkubectl create configmap nginx-proxy-conf --from-file nginx/proxy.conf\n # &gt; configmap/nginx-proxy-conf created\n\ncat pods/secure-monolith.yaml</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: &quot;secure-monolith&quot;\n  labels:\n    app: monolith\nspec:\n  containers:\n    - name: nginx\n      image: &quot;nginx:1.9.14&quot;\n      lifecycle:\n        preStop:\n          exec:\n            command: [&quot;/usr/sbin/nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]\n      volumeMounts:\n        - name: &quot;nginx-proxy-conf&quot;\n          mountPath: &quot;/etc/nginx/conf.d&quot;\n        - name: &quot;tls-certs&quot;\n          mountPath: &quot;/etc/tls&quot;\n    - name: monolith\n      image: &quot;kelseyhightower/monolith:1.0.0&quot;\n      ports:\n        - name: http\n          containerPort: 80\n        - name: health\n          containerPort: 81\n      resources:\n        limits:\n          cpu: 0.2\n          memory: &quot;10Mi&quot;\n      livenessProbe:\n        httpGet:\n          path: /healthz\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        periodSeconds: 15\n        timeoutSeconds: 5\n      readinessProbe:\n        httpGet:\n          path: /readiness\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        timeoutSeconds: 1\n  volumes:\n    - name: &quot;tls-certs&quot;\n      secret:\n        secretName: &quot;tls-certs&quot;\n    - name: &quot;nginx-proxy-conf&quot;\n      configMap:\n        name: &quot;nginx-proxy-conf&quot;\n        items:\n          - key: &quot;proxy.conf&quot;\n            path: &quot;proxy.conf&quot;</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ps\"><pre class=\"language-ps\"><code class=\"language-ps\">kubectl create -f pods/secure-monolith.yaml\n # &gt; pod/secure-monolith created</code></pre></div>\n<blockquote>\n<p>expose secure-monolith pod with kube service</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ps\"><pre class=\"language-ps\"><code class=\"language-ps\">cat services/monolith.yaml</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">kind: Service\napiVersion: v1\nmetadata:\n  name: &quot;monolith&quot;\nspec:\n  selector:\n    app: &quot;monolith&quot;\n    secure: &quot;enabled&quot;\n  ports:\n    - protocol: &quot;TCP&quot;\n      port: 443\n      targetPort: 443\n      nodePort: 31000\n  type: NodePort</code></pre></div>\n<blockquote>\n<p>Things to note:</p>\n<ol>\n<li>이 서비스는 selector를 통해 <code class=\"language-text\">app=monolith,secure=enabled</code>인 pod를 찾아 자동으로 노출한다.</li>\n<li>포트 31000의 외부 트래픽을 내부 포트 443의 nginx로 전달해야 하므로 여기서 nodeport를 expose해야 한다.</li>\n</ol>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ps\"><pre class=\"language-ps\"><code class=\"language-ps\">kubectl create -f services/monolith.yaml\n # &gt; service/monolith created</code></pre></div>\n<p><code class=\"language-text\">gcloud compute firewall-rules</code> 명령으로 노출된 nodeport의 monolith service로의 트래픽을 허용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ps\"><pre class=\"language-ps\"><code class=\"language-ps\">gcloud compute firewall-rules create allow-monolith-nodeport --allow=tcp:31000\n\n #&gt; Creating firewall...done.</code></pre></div>\n<blockquote>\n<p>get an external IP address for one of the nodes.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ps\"><pre class=\"language-ps\"><code class=\"language-ps\">gcloud compute instances list</code></pre></div>\n<blockquote>\n<p>try hitting the secure-monolith service using curl:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curl -k https://&lt;EXTERNAL_IP&gt;:31000</code></pre></div>\n<p>이 때, 연결이 실패하게 되는데, 예제에서 secure-monolith yaml에 <code class=\"language-text\">secure=enabled</code> 라벨을 빼놓았기 때문이다. 아래와 같이 <code class=\"language-text\">kubectl label pods</code>명령으로 label을 추가할 수 있고, label을 추가하면 서비스를 재시작하지 않고도 서비스가 알아서 갱신되며 endpoint가 생성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ps\"><pre class=\"language-ps\"><code class=\"language-ps\">kubectl get pods -l &quot;app=monolith,secure=enabled&quot;\n #&gt; No resources found.\nkubectl label pods secure-monolith &#39;secure-enabled&#39;\n #&gt; error: at least one label update is required\nkubectl label pods secure-monolith &#39;secure=enabled&#39;\n #&gt; pod/secure-monolith labeled\nkubectl get pods secure-monolith --show-labels\n #&gt; NAME              READY   STATUS    RESTARTS   AGE     LABELS\n #&gt; secure-monolith   2/2     Running   0          9m54s   app=monolith,secure=enabled</code></pre></div>\n<p>다시 외부 ip로 접속하면 연결이 잘 된다.</p>\n<h2 id=\"tags\"><a href=\"#tags\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>tags</h2>\n<p>  #cloud, #blog</p>","id":"847b9205-2cda-584d-995a-c6c1ab39ee40","fields":{"slug":"qwiklab-kubernetes-스터디"},"frontmatter":{"date":"2019-08-26","title":"qwiklab kubernetes 스터디","category":"blog","tags":["dev/cloud","blog"],"banner":"/assets/bg/2.jpg"},"timeToRead":3},"next":{"excerpt":"백준 3019 - 테트리스https://www.acmicpc.net/problem/3019일단 방법의 수를 구해야 하므로,\n방법의 수는 현재 블록을 놓을 수 있는 형태의 칸수 패턴들 마다 1씩 증가한다.\n그런데, 가장 큰 문제는 블록 및 블록 회전을 구현하는 것.\n회전까지 구현하려면 일일히 하면 너무 노가다일거 같은데.\n그냥…","html":"<h3 id=\"백준-3019---테트리스\"><a href=\"#%EB%B0%B1%EC%A4%80-3019---%ED%85%8C%ED%8A%B8%EB%A6%AC%EC%8A%A4\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>백준 3019 - 테트리스</h3>\n<p><a href=\"https://www.acmicpc.net/problem/3019\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.acmicpc.net/problem/3019</a></p>\n<p>일단 방법의 수를 구해야 하므로,\n방법의 수는 현재 블록을 놓을 수 있는 형태의 칸수 패턴들 마다 1씩 증가한다.\n그런데, 가장 큰 문제는 블록 및 블록 회전을 구현하는 것.\n회전까지 구현하려면 일일히 하면 너무 노가다일거 같은데.\n그냥 4개 블록을 끊어지지만 않게 구현한 모든 가지수가 필요한 것 아닌가?\n그걸 어떻게 할지가 문제다.\n사실 형태상 가로로 밀 수 있다면 모든 가로 패턴이, 세로로 밀 수 있다면 모든 세로 패턴을 구할 수 있는데,\n어떤 블록은 180도 회전하면 같은 모양이 되고, 어떤 블록들은 아니다.\n그렇게 모든 회전까지 포함한 가지수들을 구현해서,\n그리고 바닥에 놓을 수 있는지는 그 가지수들의 패턴을 역이용해서\n가장 아래에 있는 블록 기준 다른 아래에 돌출된 블록들의 상대적 위치를 기록하면\n될 거 같은데.. 구현이 어려울 거 같다.\n아무래도 지금은 블록들을 생성을 어떻게 해야 할 지 감이 안 오는데,\n각 블록의 번호의 회전 상태에 따라 아래의 패턴만 저장해서 비교해도 되지 않을까?</p>\n<p>마지막으로 생각한 방식이 정확히 맞아서 바로 성공했다. 각 바닥의 패턴, 각 블록의 상대적 바닥 패턴을 기록해서 원소별로 더한 후, 더한 결과가 수평이 맞는지 확인했다.</p>\n<details><summary>python solution</summary>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">def solve():\n    bottomPatterns={}\n    bottomPatterns[1]=[[0],[0,0,0,0]]\n    bottomPatterns[2]=[[0,0]]\n    bottomPatterns[3]=[[0,0,-1],[-1,0]]\n    bottomPatterns[4]=[[-1,0,0],[0,-1]]\n    bottomPatterns[5]=[[0,0,0],[0,-1],[-1,0,-1],[-1,0]]\n    bottomPatterns[6]=[[0,0,0],[0,0],[0,-1,-1],[-2,0]]\n    bottomPatterns[7]=[[0,0,0],[0,-2],[-1,-1,0],[0,0]]\n    \n    patterns={1:[],2:[],3:[],4:[]}\n\n    c,p=ria()\n    maps=ria()\n    for i in range(c):\n        if(i+4&lt;=c):\n            patterns[4].append(maps[i:i+4])\n        if(i+3&lt;=c):\n            patterns[3].append(maps[i:i+3])\n        if(i+2&lt;=c):\n            patterns[2].append(maps[i:i+2])\n        if(i+1&lt;=c):\n            patterns[1].append(maps[i:i+1])\n    # it(patterns)\n\n    ans = 0\n    for patArr in bottomPatterns[p]:\n        pattern=patterns[len(patArr)]\n        for pat in pattern:\n            copyPat=pat[:]\n            # if(len(patArr) != len(copyPat)):\n            #     it(&#39;ERROR&#39;)\n            base=copyPat[0]+patArr[0]\n            success=True\n            # it(&#39;patArr: &#39;, patArr, &#39; pattern: &#39;, pat)\n            for i in range(len(copyPat)):\n                copyPat[i]+=patArr[i]\n                if(base != copyPat[i]):\n                    # it(&#39;Fail for this.&#39;)\n                    success=False\n                    break\n            if(success):\n                ans+=1\n    print(ans)\n    pass</code></pre></div>\n</details>\n<h3 id=\"백준-2210---테트리스\"><a href=\"#%EB%B0%B1%EC%A4%80-2210---%ED%85%8C%ED%8A%B8%EB%A6%AC%EC%8A%A4\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>백준 2210 - 테트리스</h3>\n<p><a href=\"https://www.acmicpc.net/problem/2210\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.acmicpc.net/problem/2210</a></p>\n<p>5x5 크기 정도이므로, 주어진 대로 구현해도 될 거 같다.\n임의의 위치에서 랜덤하게 움직이는 모든 경우의 수가 몇 가지 정도일까?\n생각보다 상당히 많을거 같기도 한데, 길이도 6 제한이므로 괜찮지 않을까.</p>\n<p>라고 생각했고 pypy3로 280ms로 맞았다. 혹시 python3로 하면 시간초과될까? 하고 내봤더니 놀랍게도 152ms로 맞았다. 어째서 python3가 더 빠른거지??</p>\n<details><summary>python solution</summary>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">def solve():\n    patset=set()\n    dy=[0,0,+1,-1]\n    dx=[+1,-1,0,0]\n    maps=create2DArray(5,5,-1)\n    for r in range(5):\n        maps[r]=ria()\n    def move(y,x,pat=[]):\n        if(len(pat)==6):\n            tup = tuple(pat)\n            if(tup in patset):\n                return\n            patset.add(tup)\n            return\n        for i in range(4):\n            ny,nx=y+dy[i],x+dx[i]\n            # it(&#39;try &#39; ,ny, &#39; &#39; ,nx, &#39; &#39; , len(pat))\n            if(ny&lt;0 or ny&gt;=5 or nx&lt;0 or nx&gt;=5):\n                continue\n            tmppat=pat[:]\n            tmppat.append(maps[ny][nx])\n            move(ny,nx,tmppat)\n        pass\n\n    for r in range(5):\n        for c in range(5):\n            move(r,c)\n    \n    # it(patset)\n    print(len(patset))\n    pass</code></pre></div>\n</details>\n<h3 id=\"백준-2805---나무-자르기\"><a href=\"#%EB%B0%B1%EC%A4%80-2805---%EB%82%98%EB%AC%B4-%EC%9E%90%EB%A5%B4%EA%B8%B0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>백준 2805 - 나무 자르기</h3>\n<p><a href=\"https://www.acmicpc.net/problem/2805\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.acmicpc.net/problem/2805</a></p>\n<p>이런 경우 보통 매 반복마다 전체를 돌면 시간초과되고,\n정보를 간단하게 압축해야 한다.\n나무가 무려 백만개까지 되므로,\n근데 높이가 인덱싱 가능한 수치가 아니다. 흠 어떻게 해야 하지??\n일단 백만개나 되므로 정렬만 해도 거의 시간초과 아닌가??\n이진 탐색을 해도 될까 이문제에서?</p>\n<details><summary>python solution</summary>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">def solve():\n    n,m=ria()\n    maps=ria()\n    lo=0\n    hi=1000000000\n    def calcsum(mm):\n        sums=0\n        for i in range(n):\n            sums+=max(maps[i]-mm,0)\n        return sums\n    while(lo+1&lt;hi):\n        # if(hi-lo&lt;0.000001):\n        #     break\n        mid=(lo+hi)//2\n        cent=calcsum(mid)\n        # it(&#39;lo &#39;,lo, &#39; hi &#39;, hi, &#39; cent &#39;, cent)\n        if(cent&lt;m):\n            hi=mid\n            continue\n        else:\n            lo=mid\n            continue\n\n    # it(lo,hi)\n    print(round(lo))\n    pass</code></pre></div>\n</details>\n<h3 id=\"종만북-8장---trianglepath\"><a href=\"#%EC%A2%85%EB%A7%8C%EB%B6%81-8%EC%9E%A5---trianglepath\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>종만북 8장 - TRIANGLEPATH</h3>\n<p>동적 계획법 없이 반대로 풀기로도 풀린다.</p>\n<details><summary>cpp solution</summary>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> maps<span class=\"token punctuation\">[</span><span class=\"token number\">101</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">101</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> C<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> C<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>c<span class=\"token operator\">&lt;</span>C<span class=\"token punctuation\">;</span>c<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> r<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>r<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>r<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>c<span class=\"token operator\">&lt;=</span>r<span class=\"token punctuation\">;</span>c<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                cin <span class=\"token operator\">>></span> maps<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> r<span class=\"token operator\">=</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>r<span class=\"token operator\">>=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>r<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>c<span class=\"token operator\">&lt;=</span>r<span class=\"token punctuation\">;</span>c<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                maps<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maps<span class=\"token punctuation\">[</span>r<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> maps<span class=\"token punctuation\">[</span>r<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>c<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> maps<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// for(int r=0;r&lt;n;r++){</span>\n        <span class=\"token comment\">//     for(int c=0;c&lt;=r;c++){</span>\n        <span class=\"token comment\">//         cout &lt;&lt; maps[r][c] &lt;&lt; ' ';</span>\n        <span class=\"token comment\">//     }</span>\n        <span class=\"token comment\">//     cout &lt;&lt; '\\n';</span>\n        <span class=\"token comment\">// }</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> maps<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n</details>\n<p>여전히 vscode markdown에 cpp/c 문법 하이라이팅에 에러가 있다.</p>\n<ul>\n<li>최적 부분 구조에 속하지 않는 정보를 제하는 것이 중요하다.</li>\n</ul>\n<p>그러나 이렇게 푸는 것은 풀리긴 하지만 별로 배우는 건 없다. 지금 다시 상세히 읽으니 이해가 된다. 대체 왜 각 상태의 모든 정보를 담은 <code class=\"language-text\">searchMax(y,x,sum)</code>을 그대로 메모이제이션을 해서는 안 되는지. 그렇게 하려면 두 가지 문제가 있다:</p>\n<ol>\n<li><code class=\"language-text\">sum</code>을 기준으로 메모이제이션 하므로 숫자의 크기가 클 경우 많은 메모리가 필요하게 된다.</li>\n<li><code class=\"language-text\">sum</code>을 기준으로 하므로 합이 겹치지 않는 경우는 전부 다른 경우로 계산된다.</li>\n</ol>\n<p>그런데 어떻게 여기서 <code class=\"language-text\">sum</code>을 빼도 된다고 생각할 수 있을까? 그 기준은 무조건 <strong>이미 선택한 정보인가</strong> 이다. <code class=\"language-text\">y, x</code>는 앞으로 재귀 호출이 선택할 정보들을 결정하기에 필요한 정보지만, <code class=\"language-text\">sum</code>은 이미 선택한 정보다. 여전히 잘 와닿지 않는다. 그렇다면 이렇게 물어보자. '<code class=\"language-text\">sum</code>이 바뀌고 다른게 그대로라면, 앞으로의 선택에 영향을 주는가?'. </p>\n<h3 id=\"종만북-8장---lis\"><a href=\"#%EC%A2%85%EB%A7%8C%EB%B6%81-8%EC%9E%A5---lis\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>종만북 8장 - LIS</h3>\n<details><summary>cpp solution</summary>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">505</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> mins<span class=\"token punctuation\">[</span><span class=\"token number\">505</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 역시 cache를 505x505로 하니 메모리 초과가 되버리는거 같다.</span>\n<span class=\"token comment\">// 그렇다면, 그냥 모든 수 500가지에 대해, 그 수를 기준으로 치고, 500개 중 넘는 걸 세는 것을 해서</span>\n<span class=\"token comment\">// 최대 길이를 저장한다면? 시간복잡도 500*500*50=250000*50=1250,0000 cpp로는 충분할지도. 하지만 이건</span>\n<span class=\"token comment\">// 전혀 동적계획이 아닌데.. 아니, 넘는 걸 센다고 해도 그게 그대로 길이가 되지 않는구나..</span>\n<span class=\"token comment\">// 현재 쓰는 코드도 start를 지정하면 cache에서 start를 뺄 수 있는것 아닌가?</span>\n<span class=\"token comment\">// 음 역시 len은 선택해온 정보고, start는 앞으로 선택을 결정하는 정보니 len을 지워야 하는건가??</span>\n<span class=\"token comment\">// 그렇지만 len 없이 어떻게 점화식을 나타내지?</span>\n\n<span class=\"token comment\">// 사실 기억으론 배열에 인덱스에 해당하는 길이의 최대한 작은 수를 저장하는 방식으로 관리하는 것으로 기억나긴 하는데.. 그건 그냥 기억으로 푸는 것일 뿐. 왜 그렇게 해야 하는지 스스로 논리적으로 유도하기가 힘들다.</span>\n<span class=\"token comment\">// </span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> C<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> C<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>c<span class=\"token operator\">&lt;</span>C<span class=\"token punctuation\">;</span>c<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 어떻게 풀었었는지 까먹었다.</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> t<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>t<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>t<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            cin <span class=\"token operator\">>></span> arr<span class=\"token punctuation\">[</span>t<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            mins<span class=\"token punctuation\">[</span>t<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>BIG<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 특정 수를 선택하면, 기준 수가 늘어나버리고,</span>\n        <span class=\"token comment\">// 선택하지 않으면 길이가 짧아진다.</span>\n        <span class=\"token comment\">// 즉, 길이가 길거나 선택 수가 작은 정보들을 우선순위 큐를 사용하여 관리한다면?</span>\n        <span class=\"token comment\">// 아니면, 각 길이별로 배열에, 그 최소 선택수를 저장하여 관리하면서,</span>\n        <span class=\"token comment\">// 높은 수를 만나게 되면 길이+1 칸에 그 높은수를 저장한다면?,</span>\n        <span class=\"token comment\">// 그러면 특정 수에 대해 어느 칸에 더할 수 있는지 매 번 찾아야 한다..</span>\n        \n        <span class=\"token keyword\">int</span> ans<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> cur <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cur<span class=\"token operator\">&lt;</span>mins<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">></span>ans<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        ans<span class=\"token operator\">=</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    mins<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>cur<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                j<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\">// if(cur &lt; mins[ans-1]){</span>\n            <span class=\"token comment\">//     mins[ans-1]=cur;</span>\n            <span class=\"token comment\">// }</span>\n\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// for(int k=0;k&lt;n;k++){</span>\n        <span class=\"token comment\">//     if(mins[k]==BIG){</span>\n        <span class=\"token comment\">//         ans=k;</span>\n        <span class=\"token comment\">//     }</span>\n        <span class=\"token comment\">// }</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>분명 위의 문제는 최적 부분 구조에 이전의 기록인 합산이 포함되지 않는 구조여서 뺄 수 있었지만, 이번 문제에서는 특정 위치에서 특정 start가 정해져도 최대 길이인지 결정하려면 현재 길이가 필요해지고, 현재 길이를 캐시하려고 하면 메모리가 너무 늘어나버리는 문제가 있었다. 나는 반드시 재귀를 호출할 때 인덱스 0부터 시작해야한다고 생각해서 시그니쳐를 <code class=\"language-text\">search(int cur, int start, int sum)</code> 이런 식으로 생각해서, 인덱스를 증가하면서 이전 수와 비교 (또는 현재 수 기준 다음 수와 비교)하여 감소했으면, 초기화하거나, 그대로 진행하는 것 중의 최대, 증가했으면, 선택하거나, 그대로 진행하는것 중의 최대 이렇게 4가지 선택을 해서 계산하게 했으나 시간초과가 났다.</p>\n<p>그냥 바깥 반복문에서 모든 start를 시도하게 하면, 또 그 search에서 현 start 이상의 다른 start를 지정하는 식으로 호출될 수 있다. 그리고 그렇게 <code class=\"language-text\">search(int start)</code>를 <code class=\"language-text\">start</code> 값 이상의 lis라고 정의하면 <code class=\"language-text\">sum</code>도 필요 없게 된다. 어째서 그럴까? 어떻게 해야 이런 풀이를 생각해낼 수 있을까..</p>\n<p>배울 기법:</p>\n<ul>\n<li><code class=\"language-text\">S[-1]=-inf</code>같은 식으로 지정하여, 바깥 반복문을 돌면서 최대값을 찾아야 하는 것을 -1을 호출하여 모든 경우를 다시 호출하게 만들기(?)</li>\n</ul>\n</details>\n<h2 id=\"tags\"><a href=\"#tags\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>tags</h2>\n<p>  #sport, #blog</p>","id":"ad962ba3-4ef5-5a48-b6fd-476362c9a933","fields":{"slug":"백준-문제-풀이"},"frontmatter":{"date":"2019-08-28","title":"백준 문제 풀이","category":"sport","tags":["dev/sport","blog"],"banner":"/assets/bg/2.jpg"},"timeToRead":6}}}